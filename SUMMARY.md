I have built a CTA-PKMS tool. Here’s how I did it:

# Initial Attempt

I first brainstormed project ideas with Gemini. Once I settled on project features, I thought about implementation. At first, I intended to start off with using speckit to have an initial scaffold, then build on top of it with github copilot. I drafted a constitution based on code quality, code clarity, testing, and user experience/ux. After that, I specified that I’d like to be able to make a CTA-PKMS tool that allows for the user to create/delete/amend tasks (which include name, description, status, and optionally location). The tool should also allow for users to save commutes (name, departure_station, arrival_station), which they can access later when planning a commute. The particular project description was generated by Gemini, which I then put into speckit when running speckit.specify. Then for the planning phase, I outlined that the app should use Typer for the CLI, and that the planning function should use the OpenAI Chat Completions API + CTA Train Tracker and CTA Service Alerts APIs to return the best commute for the conditions, as well as the next arriving train. However, on implementation, for reasons that could either be my fault or just the nuances of dealing with something as experimental as speckit and/or the AI itself, it failed quite miserably. It ended up only making a “greet()” function, which greets the user, as well as attempts to load data (which I realized I couldn’t rely on AI to generate, so I ended up importing the data via CTA’s GTFS feed for the next attempt).

# Second Attempt 

After this experience, I decided on another approach. I would mostly use Github Copilot to implement the project’s features from start to finish, while also asking Gemini via its web interface any miscellaneous questions that may need answers (for example, how to use git lfs, as my data was over Github’s 100MB limit). I used the same project description as before, this time inputting it into Github Copilot on agent mode using GPT 4.1, requesting that we build the app step-by-step, and advising it to ask plenty of clarification questions, and to not do anything on its own / always ask before implementing. 

## Static Data

We started with implementing the static knowledge base, which consisted of various files from CTA’s GTFS feed as mentioned before. I had Copilot create a json_converter, to convert the files from txt into jsonl files. I wanted my project to consist strictly of CTA’s ‘L’ routes, with no regard for bus service, so I spent much time filtering any data pertaining to bus routes. At first, I asked the agent to filter the data itself, but it never worked consistently. Consequently, I again used Copilot to create a program relating to data manipulation, this time filter_stop_times.py to get rid of any bus routes in the stop_times.jsonl file. The other files were easy enough to filter manually. 

## Feature Implementation

I used Copilot to implement the first feature, which was the ability to manage tasks. It scaffolded it quite quickly, but it only included name as a task attribute. I prompted Copilot to add description, status, and optionally location as task attributes, and everything worked properly after some more minor tweaks. I then attempted to implement the commute management feature, but ran into some roadblocks regarding each station’s unique numeric identifier not being saved, which risks commute planning not being reliable. I elected for a TUI, which allows for a user to select a line, then a station, when selecting departure and arrival stations, which would ensure that the unique numeric identifier would be saved (as long as I created a new file which contains the route-stations, which interestingly the GTFS feed did not already have).

## Back to Static Data 
GTFS files work via storing routes in routes.jsonl, which contain certain identifiable runs, stored in trips.jsonl, which take place at certain times. Those runs then stop certain platforms at certain times, which are stored at stop_times.jsonl. Then, those specific platforms track to a certain parent station, stored in stops.jsonl.  For my TUI for commute management to work properly, I would have to make a file which connects station names to station parent IDs. I initially had copilot draft parent_station_lookup.py, which would look at a certain jsonl file to find the parent_station of each platform mentioned in the runs located in that json file in question. I would then input the data manually into route-stations.jsonl. I realized that manual data entry was pointless, and that I can just have a python file input the data for me. I then had Copilot create enrich_placeholder.py, which would do just that. 

## Back to Feature Implementation
Once this was in place, the commute management feature worked without problems after some minor tweaks. I then had Copilot draft another feature implementation, which was the ability to see the next 5 arrivals of any station. It uses the same TUI as the commute management feature. This functioned properly after some minor fixes as well. Then, I had Copilot scaffold the last feature, which was commute planning via OpenAI Chat Completions API + CTA APIs. 

## Testing 
Testing was completed via pytest. Copilot drafted the tests, and the program passed all but one test on the first try. After a minor fix, the program passed all tests.

# Uploading to Github
I got errors when I was trying to push my project saying that some of my files were too large. I asked Gemini for a solution and it recommended and showed me how to implement git lfs.

# Documentation 
Copilot drafted a README.md file.
